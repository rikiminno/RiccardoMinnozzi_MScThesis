% This code was generated using ADiGator version 1.4
% Â©2010-2014 Matthew J. Weinstein and Anil V. Rao
% ADiGator may be obtained at https://sourceforge.net/projects/adigator/ 
% Contact: mweinstein@ufl.edu
% Bugs/suggestions may be reported to the sourceforge forums
%                    DISCLAIMER
% ADiGator is a general-purpose software distributed under the GNU General
% Public License version 3.0. While the software is distributed with the
% hope that it will be useful, both the software and generated code are
% provided 'AS IS' with NO WARRANTIES OF ANY KIND and no merchantability
% or fitness for any purpose or application.

function Xdot = ft_1_t_ADiGatorJac(t,X)
global ADiGator_ft_1_t_ADiGatorJac
if isempty(ADiGator_ft_1_t_ADiGatorJac); ADiGator_LoadData(); end
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ft_1_t_ADiGatorJac.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % Augmented state derivative wrapper function for phase 1,
%User Line: % automatically generated by the PhaseManager class on 06-Dec-2024 12:49:23
%User Line: % Increase dynamics function evaluations
global HOIST_fevalsCount_ft 
%User Line: global
HOIST_fevalsCount_ft = HOIST_fevalsCount_ft + 1;
%User Line: HOIST_fevalsCount_ft = HOIST_fevalsCount_ft + 1;
x.f = X(Gator1Data.Index1,1);
%User Line: x = X(1: 4, 1);
u.f = X(5,1);
%User Line: u = X(5: 5, 1);
w.f = X(6,1);
%User Line: w = X(6: 6, 1);
cadainput2_1.dt = t.dt; cadainput2_1.f = t.f;
%User Line: cadainput2_1 = t;
cadainput2_2.f = x.f;
%User Line: cadainput2_2 = x;
cadainput2_3.f = u.f;
%User Line: cadainput2_3 = u;
cadainput2_4.f = w.f;
%User Line: cadainput2_4 = w;
cadaoutput2_1 = ADiGator_state_derivative_1(cadainput2_1,cadainput2_2,cadainput2_3,cadainput2_4);
% Call to function: state_derivative_1
xdot.dt = cadaoutput2_1.dt; xdot.f = cadaoutput2_1.f;
%User Line: xdot = cadaoutput2_1;
udot.f =  zeros(1, 1);
%User Line: udot = zeros(1, 1);
wdot.f =  zeros(1, 1);
%User Line: wdot = zeros(1, 1);
cada1td1 = zeros(2,1);
cada1td1(Gator1Data.Index2) = xdot.dt;
Xdot.dt = cada1td1;
Xdot.f = [xdot.f;udot.f;wdot.f];
%User Line: Xdot = [xdot; udot; wdot];
Xdot.dt_size = 6;
Xdot.dt_location = Gator1Data.Index3;
end
function xdot = ADiGator_state_derivative_1(t,x,u,w)
global ADiGator_ft_1_t_ADiGatorJac
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ADiGator_state_derivative_1.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % function that computes the state derivative
global auxdata 
%User Line: global
%User Line: % assemble state
rbar.f = x.f(1);
%User Line: rbar = x(1);
tbar.f = x.f(2);
%User Line: tbar = x(2);
ubar.f = x.f(3);
%User Line: ubar = x(3);
vbar.f = x.f(4);
%User Line: vbar = x(4);
theta.dt = auxdata.thetaf.*t.dt;
theta.f = t.f*auxdata.thetaf;
%User Line: theta = t * auxdata.thetaf;
%User Line: % define rotation matrices
trueRAAN.f = 180 - auxdata.Omg;
%User Line: trueRAAN = 180 - auxdata.Omg;
cadainput10_1.f = trueRAAN.f;
%User Line: cadainput10_1 = trueRAAN;
cadaoutput10_1 = ADiGator_rotate_z_deg(cadainput10_1);
% Call to function: rotate_z_deg
R_Omg.f = cadaoutput10_1.f;
%User Line: R_Omg = cadaoutput10_1;
cadainput8_1 = auxdata.inc;
%User Line: cadainput8_1 = auxdata.inc;
cadaoutput8_1 = ADiGator_rotate_x_deg(cadainput8_1);
% Call to function: rotate_x_deg
R_inc.f = cadaoutput8_1.f;
%User Line: R_inc = cadaoutput8_1;
cadainput9_1.dt = theta.dt; cadainput9_1.f = theta.f;
%User Line: cadainput9_1 = theta;
cadaoutput9_1 = ADiGator_rotate_z(cadainput9_1);
% Call to function: rotate_z
R_CRK_to_RSW.dt = cadaoutput9_1.dt; R_CRK_to_RSW.f = cadaoutput9_1.f;
%User Line: R_CRK_to_RSW = cadaoutput9_1;
R_CRK_to_IJK.f = R_Omg.f*R_inc.f;
%User Line: R_CRK_to_IJK = R_Omg * R_inc;
cada1f1dt = R_CRK_to_RSW.dt(Gator1Data.Index1);
cada1f1 = R_CRK_to_RSW.f.';
cada1td1 = zeros(3,2);
cada1td1(Gator1Data.Index2) = cada1f1dt;
cada1td1 = R_CRK_to_IJK.f*cada1td1;
cada1td1 = cada1td1(:);
R_RSW_to_IJK.dt = cada1td1(Gator1Data.Index3);
R_RSW_to_IJK.f = R_CRK_to_IJK.f*cada1f1;
%User Line: R_RSW_to_IJK = R_CRK_to_IJK * R_CRK_to_RSW';
cada1f1 = tbar.f*auxdata.T0;
tDays.f = cada1f1/86400;
%User Line: tDays = tbar * auxdata.T0 / 86400;
cadainput10_1.f = tDays.f;
%User Line: cadainput10_1 = tDays;
cadaoutput10_1 = ADiGator_rotate_z_deg(cadainput10_1);
% Call to function: rotate_z_deg
R_SLF_to_IJK.f = cadaoutput10_1.f;
%User Line: R_SLF_to_IJK = cadaoutput10_1;
%User Line: % define unit vectors
i.f =  [1; 0; 0];
%User Line: i = [1; 0; 0];
j.f =  [0; 1; 0];
%User Line: j = [0; 1; 0];
k.f =  [0; 0; 1];
%User Line: k = [0; 0; 1];
r_SS.f = R_SLF_to_IJK.f*i.f;
%User Line: r_SS = R_SLF_to_IJK * i;
%User Line: % define primer yaw vector
yaw.f = u.f;
%User Line: yaw = u;
%User Line: % assemble primer vector in local frame
cada1f1 = sin(yaw.f);
cada1f2 = cos(yaw.f);
p_RSW.f = [cada1f1;cada1f2;0];
%User Line: p_RSW = [sin(yaw); cos(yaw); 0];
%User Line: % rotate primer vector to inertial
cada1td1 = zeros(3,3);
cada1td1(Gator1Data.Index4) = R_RSW_to_IJK.dt;
cada1td1 = p_RSW.f.'*cada1td1;
cada1td1 = cada1td1(:);
p_IJK.dt = cada1td1(Gator1Data.Index5);
p_IJK.f = R_RSW_to_IJK.f*p_RSW.f;
%User Line: p_IJK = R_RSW_to_IJK * p_RSW;
%User Line: % compute angle between primer vector and sun line
cadainput3_1.dt = p_IJK.dt; cadainput3_1.f = p_IJK.f;
%User Line: cadainput3_1 = p_IJK;
cadainput3_2.f = r_SS.f;
%User Line: cadainput3_2 = r_SS;
cadaoutput3_1 = ADiGator_angleBetweenVectors(cadainput3_1,cadainput3_2);
% Call to function: angleBetweenVectors
psi.dt = cadaoutput3_1.dt; psi.f = cadaoutput3_1.f;
%User Line: psi = cadaoutput3_1;
%User Line: % compute optimal alpha angle from psi
cada1f1dt = cos(psi.f).*psi.dt;
cada1f1 = sin(psi.f);
cada1f2dt = cada1f1dt./3;
cada1f2 = cada1f1/3;
cada1f3dt = 1./sqrt(1-cada1f2.^2).*cada1f2dt;
cada1f3 = asin(cada1f2);
cada1td1 = psi.dt;
cada1td1 = cada1td1 + -cada1f3dt;
cada1f4dt = cada1td1;
cada1f4 = psi.f - cada1f3;
alpha.dt = 0.5.*cada1f4dt;
alpha.f = 0.5*cada1f4;
%User Line: alpha = 1/2*(psi - asin(sin(psi)/3));
%User Line: % compute the clock angle as the angle between the primer vector and the
%User Line: % chosen reference direction z (valid since it is perpendicular to the
%User Line: % Sun-line)
cada1f1dt = p_IJK.dt(2);
cada1f1 = p_IJK.f(2);
cada1f2dt = p_IJK.dt(3);
cada1f2 = p_IJK.f(3);
cada1td1 = cada1f2./(cada1f2.^2+cada1f1.^2).*cada1f1dt;
cada1td1 = cada1td1 + -cada1f1./(cada1f2.^2+cada1f1.^2).*cada1f2dt;
delta.dt = cada1td1;
delta.f = atan2(cada1f1,cada1f2);
%User Line: delta = atan2(p_IJK(2), p_IJK(3));
%User Line: % compute the solar sail acceleration in SunLight-frame
cada1f1dt = -sin(alpha.f).*alpha.dt;
cada1f1 = cos(alpha.f);
cada1f2dt = 2.*cada1f1.^(2-1).*cada1f1dt;
cada1f2 = cada1f1^2;
aMod.dt = auxdata.a0bar.*cada1f2dt;
aMod.f = auxdata.a0bar*cada1f2;
%User Line: aMod = auxdata.a0bar * cos(alpha)^2;
cada1f1dt = -sin(alpha.f).*alpha.dt;
cada1f1 = cos(alpha.f);
cada1td1 = cada1f1.*aMod.dt;
cada1td1 = cada1td1 + aMod.f.*cada1f1dt;
cada1f2dt = cada1td1;
cada1f2 = aMod.f*cada1f1;
cada1tempdt = cada1f2dt(Gator1Data.Index6);
cada1tf1 = i.f(1);
cada1f3dt = cada1tf1(:).*cada1tempdt(1);
cada1f3 = cada1f2*i.f;
cada1f4dt = cos(alpha.f).*alpha.dt;
cada1f4 = sin(alpha.f);
cada1td1 = cada1f4.*aMod.dt;
cada1td1 = cada1td1 + aMod.f.*cada1f4dt;
cada1f5dt = cada1td1;
cada1f5 = aMod.f*cada1f4;
cada1f6dt = cos(delta.f).*delta.dt;
cada1f6 = sin(delta.f);
cada1td1 = cada1f6.*cada1f5dt;
cada1td1 = cada1td1 + cada1f5.*cada1f6dt;
cada1f7dt = cada1td1;
cada1f7 = cada1f5*cada1f6;
cada1tempdt = cada1f7dt(Gator1Data.Index7);
cada1tf1 = j.f(2);
cada1f8dt = cada1tf1(:).*cada1tempdt(2);
cada1f8 = cada1f7*j.f;
cada1td1 = zeros(2,1);
cada1td1(1) = cada1f3dt;
cada1td1(2) = cada1td1(2) + cada1f8dt;
cada1f9dt = cada1td1;
cada1f9 = cada1f3 + cada1f8;
cada1f10dt = cos(alpha.f).*alpha.dt;
cada1f10 = sin(alpha.f);
cada1td1 = cada1f10.*aMod.dt;
cada1td1 = cada1td1 + aMod.f.*cada1f10dt;
cada1f11dt = cada1td1;
cada1f11 = aMod.f*cada1f10;
cada1f12dt = -sin(delta.f).*delta.dt;
cada1f12 = cos(delta.f);
cada1td1 = cada1f12.*cada1f11dt;
cada1td1 = cada1td1 + cada1f11.*cada1f12dt;
cada1f13dt = cada1td1;
cada1f13 = cada1f11*cada1f12;
cada1tempdt = cada1f13dt(Gator1Data.Index8);
cada1tf1 = k.f(3);
cada1f14dt = cada1tf1(:).*cada1tempdt(3);
cada1f14 = cada1f13*k.f;
cada1td1 = zeros(3,1);
cada1td1(Gator1Data.Index9) = cada1f9dt;
cada1td1(3) = cada1td1(3) + cada1f14dt;
a_SLF.dt = cada1td1;
a_SLF.f = cada1f9 + cada1f14;
%User Line: a_SLF = aMod * cos(alpha) .* i     + aMod * sin(alpha) * sin(delta) * j     + aMod * sin(alpha) * cos(delta) * k;
%User Line: % rotate the sail acceleration to local frame
cada1td1 = zeros(3,1);
cada1td1(Gator1Data.Index10) = a_SLF.dt;
cada1td1 = R_SLF_to_IJK.f*cada1td1;
cada1td1 = cada1td1(:);
a_IJK.dt = cada1td1(Gator1Data.Index11);
a_IJK.f = R_SLF_to_IJK.f*a_SLF.f;
%User Line: a_IJK = R_SLF_to_IJK * a_SLF;
cada1f1dt = R_RSW_to_IJK.dt(Gator1Data.Index12);
cada1f1 = R_RSW_to_IJK.f.';
cada1td2 = zeros(3,2);
cada1td2(Gator1Data.Index13) = cada1f1dt;
cada1td2 = a_IJK.f.'*cada1td2;
cada1td1 = zeros(3,1);
cada1td1(Gator1Data.Index15) = cada1td2(Gator1Data.Index14);
cada1td2 = zeros(3,1);
cada1td2(Gator1Data.Index16) = a_IJK.dt;
cada1td2 = cada1f1*cada1td2;
cada1td2 = cada1td2(:);
cada1td1 = cada1td1 + cada1td2(Gator1Data.Index17);
a_RSW.dt = cada1td1;
a_RSW.f = cada1f1*a_IJK.f;
%User Line: a_RSW = R_RSW_to_IJK' * a_IJK;
%User Line: % assemble EOMs
eta = auxdata.eta;
%User Line: eta = auxdata.eta;
cada1f1 = vbar.f/rbar.f;
cada1f2 = cada1f1*eta;
sigma.f = cada1f2/auxdata.thetaf;
%User Line: sigma = (vbar / rbar) * eta / auxdata.thetaf;
cada1f1 = ubar.f*eta;
drbar.f = cada1f1/sigma.f;
%User Line: drbar = ubar * eta / sigma;
dtime.f = 1/sigma.f;
%User Line: dtime = 1 / sigma;
cada1f1 = vbar.f^2;
cada1f2 = cada1f1/rbar.f;
cada1f3 = rbar.f^2;
cada1f4 = 1/cada1f3;
cada1f5 = cada1f2 - cada1f4;
cada1f6 = cada1f5*eta;
cada1f7dt = a_RSW.dt(1);
cada1f7 = a_RSW.f(1);
cada1f8dt = cada1f7dt;
cada1f8 = cada1f6 + cada1f7;
dubar.dt = cada1f8dt./sigma.f;
dubar.f = cada1f8/sigma.f;
%User Line: dubar = ((vbar^2/rbar - 1/rbar^2) * eta + a_RSW(1)) / sigma;
cada1f1 = uminus(ubar.f);
cada1f2 = cada1f1*vbar.f;
cada1f3 = cada1f2/rbar.f;
cada1f4 = cada1f3*eta;
cada1f5dt = a_RSW.dt(2);
cada1f5 = a_RSW.f(2);
cada1f6dt = cada1f5dt;
cada1f6 = cada1f4 + cada1f5;
dvbar.dt = cada1f6dt./sigma.f;
dvbar.f = cada1f6/sigma.f;
%User Line: dvbar = (- ubar * vbar / rbar * eta + a_RSW(2)) / sigma;
cada1td1 = zeros(2,1);
cada1td1(1) = dubar.dt;
cada1td1(2) = dvbar.dt;
xdot.dt = cada1td1;
xdot.f = [drbar.f;dtime.f;dubar.f;dvbar.f];
%User Line: xdot = [drbar; dtime; dubar; dvbar];
end
function angle = ADiGator_angleBetweenVectors(vec1,vec2)
global ADiGator_ft_1_t_ADiGatorJac
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ADiGator_angleBetweenVectors.Gator1Data;
% ADiGator Start Derivative Computations
cadainput5_1.dt = vec1.dt; cadainput5_1.f = vec1.f;
%User Line: cadainput5_1 = vec1;
cadainput5_2.f = vec2.f;
%User Line: cadainput5_2 = vec2;
cadaoutput5_1 = ADiGator_myCross(cadainput5_1,cadainput5_2);
% Call to function: myCross
c.dt = cadaoutput5_1.dt; c.f = cadaoutput5_1.f;
%User Line: c = cadaoutput5_1;
cadainput4_1.dt = c.dt; cadainput4_1.f = c.f;
%User Line: cadainput4_1 = c;
cadaoutput4_1 = ADiGator_myNorm(cadainput4_1);
% Call to function: myNorm
n.dt = cadaoutput4_1.dt; n.f = cadaoutput4_1.f;
%User Line: n = cadaoutput4_1;
cada1f1dt = vec1.dt;
cada1f1 = vec1.f.';
cada1td1 = zeros(3,1);
cada1td1(Gator1Data.Index1) = cada1f1dt;
cada1td1 = vec2.f.'*cada1td1;
cada1td1 = cada1td1(:);
d.dt = cada1td1(1);
d.f = cada1f1*vec2.f;
%User Line: d = vec1' * vec2;
cada1td1 = d.f./(d.f.^2+n.f.^2).*n.dt;
cada1td1 = cada1td1 + -n.f./(d.f.^2+n.f.^2).*d.dt;
angle_tmp.dt = cada1td1;
angle_tmp.f = atan2(n.f,d.f);
%User Line: angle_tmp = atan2(n, d);
cadainput6_1.dt = angle_tmp.dt; cadainput6_1.f = angle_tmp.f;
%User Line: cadainput6_1 = angle_tmp;
cadaoutput6_1 = ADiGator_mySign(cadainput6_1);
% Call to function: mySign
angSign.f = cadaoutput6_1.f;
%User Line: angSign = cadaoutput6_1;
angle.dt = angSign.f.*angle_tmp.dt;
angle.f = angSign.f*angle_tmp.f;
%User Line: angle = angSign * angle_tmp;
end
function n = ADiGator_myNorm(vec)
global ADiGator_ft_1_t_ADiGatorJac
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ADiGator_myNorm.Gator1Data;
% ADiGator Start Derivative Computations
cada1f1dt = vec.dt(1);
cada1f1 = vec.f(1);
cada1f2dt = 2.*cada1f1.^(2-1).*cada1f1dt;
cada1f2 = cada1f1^2;
cada1f3dt = vec.dt(2);
cada1f3 = vec.f(2);
cada1f4dt = 2.*cada1f3.^(2-1).*cada1f3dt;
cada1f4 = cada1f3^2;
cada1td1 = cada1f2dt;
cada1td1 = cada1td1 + cada1f4dt;
cada1f5dt = cada1td1;
cada1f5 = cada1f2 + cada1f4;
cada1f6dt = vec.dt(3);
cada1f6 = vec.f(3);
cada1f7dt = 2.*cada1f6.^(2-1).*cada1f6dt;
cada1f7 = cada1f6^2;
cada1td1 = cada1f5dt;
cada1td1 = cada1td1 + cada1f7dt;
cada1f8dt = cada1td1;
cada1f8 = cada1f5 + cada1f7;
n.dt = (1/2)./sqrt(cada1f8).*cada1f8dt;
n.dt(cada1f8 == 0 & cada1f8dt == 0) = 0;
n.f = sqrt(cada1f8);
%User Line: n = sqrt(vec(1)^2 + vec(2)^2 + vec(3)^2);
end
function result = ADiGator_myCross(vec1,vec2)
global ADiGator_ft_1_t_ADiGatorJac
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ADiGator_myCross.Gator1Data;
% ADiGator Start Derivative Computations
result.f =  zeros(3, 1);
%User Line: result = zeros(3, 1);
cada1f1dt = vec1.dt(2);
cada1f1 = vec1.f(2);
cada1f2 = vec2.f(3);
cada1f3 = cada1f1*cada1f2;
cada1f4dt = vec1.dt(3);
cada1f4 = vec1.f(3);
cada1f5 = vec2.f(2);
cada1f6dt = cada1f5.*cada1f4dt;
cada1f6 = cada1f4*cada1f5;
cada1f7dt = -cada1f6dt;
cada1f7 = cada1f3 - cada1f6;
result.dt = cada1f7dt;
result.f(1,1) = cada1f7;
%User Line: result(1, 1) = vec1(2) * vec2(3) - vec1(3) * vec2(2);
cada1f1dt = vec1.dt(3);
cada1f1 = vec1.f(3);
cada1f2 = vec2.f(1);
cada1f3dt = cada1f2.*cada1f1dt;
cada1f3 = cada1f1*cada1f2;
cada1f4dt = vec1.dt(1);
cada1f4 = vec1.f(1);
cada1f5 = vec2.f(3);
cada1f6 = cada1f4*cada1f5;
cada1f7dt = cada1f3dt;
cada1f7 = cada1f3 - cada1f6;
cada1td1 = zeros(2,1);
cada1td1(2) = cada1f7dt;
cada1td1(1) = result.dt(1);
result.dt = cada1td1;
result.f(2,1) = cada1f7;
%User Line: result(2, 1) = vec1(3) * vec2(1) - vec1(1) * vec2(3);
cada1f1dt = vec1.dt(1);
cada1f1 = vec1.f(1);
cada1f2 = vec2.f(2);
cada1f3dt = cada1f2.*cada1f1dt;
cada1f3 = cada1f1*cada1f2;
cada1f4dt = vec1.dt(2);
cada1f4 = vec1.f(2);
cada1f5 = vec2.f(1);
cada1f6dt = cada1f5.*cada1f4dt;
cada1f6 = cada1f4*cada1f5;
cada1td1 = cada1f3dt;
cada1td1 = cada1td1 + -cada1f6dt;
cada1f7dt = cada1td1;
cada1f7 = cada1f3 - cada1f6;
cada1td1 = zeros(3,1);
cada1td1(3) = cada1f7dt;
cada1td1(Gator1Data.Index1) = result.dt(Gator1Data.Index2);
result.dt = cada1td1;
result.f(3,1) = cada1f7;
%User Line: result(3, 1) = vec1(1) * vec2(2) - vec1(2) * vec2(1);
end
function s = ADiGator_mySign(num)
global ADiGator_ft_1_t_ADiGatorJac
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ADiGator_mySign.Gator1Data;
% ADiGator Start Derivative Computations
cadaconditional1 = ge(num.f,0);
%User Line: cadaconditional1 = num >= 0;
if cadaconditional1
    s.f =  1;
    %User Line: s = 1;
else
    s.f =  -1;
    %User Line: s = -1;
end
end
function R = ADiGator_rotate_x_deg(alpha)
global ADiGator_ft_1_t_ADiGatorJac
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ADiGator_rotate_x_deg.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % function to output the rotation matrix for a rotation around the x axis
%User Line: % by angle alpha [deg]
R.f =  zeros(3, 3);
%User Line: R = zeros(3, 3);
R.f(1,1) = 1;
%User Line: R(1, 1) = 1;
cada1f1 = cosd(alpha);
R.f(2,2) = cada1f1;
%User Line: R(2, 2) = cosd(alpha);
cada1f1 = sind(alpha);
cada1f2 = uminus(cada1f1);
R.f(2,3) = cada1f2;
%User Line: R(2, 3) = -sind(alpha);
cada1f1 = sind(alpha);
R.f(3,2) = cada1f1;
%User Line: R(3, 2) = sind(alpha);
cada1f1 = cosd(alpha);
R.f(3,3) = cada1f1;
%User Line: R(3, 3) = cosd(alpha);
end
function R = ADiGator_rotate_z(gamma)
global ADiGator_ft_1_t_ADiGatorJac
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ADiGator_rotate_z.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % function to output the rotation matrix for a rotation around the z axis
%User Line: % by angle gamma [rad]
R.f =  zeros(3, 3);
%User Line: R = zeros(3, 3);
cada1f1dt = -sin(gamma.f).*gamma.dt;
cada1f1 = cos(gamma.f);
R.dt = cada1f1dt;
R.f(1,1) = cada1f1;
%User Line: R(1, 1) = cos(gamma);
cada1f1dt = cos(gamma.f).*gamma.dt;
cada1f1 = sin(gamma.f);
cada1f2dt = -cada1f1dt;
cada1f2 = uminus(cada1f1);
cada1td1 = zeros(2,1);
cada1td1(2) = cada1f2dt;
cada1td1(1) = R.dt(1);
R.dt = cada1td1;
R.f(1,2) = cada1f2;
%User Line: R(1, 2) = -sin(gamma);
cada1f1dt = cos(gamma.f).*gamma.dt;
cada1f1 = sin(gamma.f);
cada1td1 = zeros(3,1);
cada1td1(2) = cada1f1dt;
cada1td1(Gator1Data.Index1) = R.dt(Gator1Data.Index2);
R.dt = cada1td1;
R.f(2,1) = cada1f1;
%User Line: R(2, 1) = sin(gamma);
cada1f1dt = -sin(gamma.f).*gamma.dt;
cada1f1 = cos(gamma.f);
cada1td1 = zeros(4,1);
cada1td1(4) = cada1f1dt;
cada1td1(Gator1Data.Index3) = R.dt(Gator1Data.Index4);
R.dt = cada1td1;
R.f(2,2) = cada1f1;
%User Line: R(2, 2) = cos(gamma);
R.f(3,3) = 1;
%User Line: R(3, 3) = 1;
end
function R = ADiGator_rotate_z_deg(gamma)
global ADiGator_ft_1_t_ADiGatorJac
Gator1Data = ADiGator_ft_1_t_ADiGatorJac.ADiGator_rotate_z_deg.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % function to output the rotation matrix for a rotation around the z axis
%User Line: % by angle gamma [deg]
R.f =  zeros(3, 3);
%User Line: R = zeros(3, 3);
cada1f1 = cosd(gamma.f);
R.f(1,1) = cada1f1;
%User Line: R(1, 1) = cosd(gamma);
cada1f1 = sind(gamma.f);
cada1f2 = uminus(cada1f1);
R.f(1,2) = cada1f2;
%User Line: R(1, 2) = -sind(gamma);
cada1f1 = sind(gamma.f);
R.f(2,1) = cada1f1;
%User Line: R(2, 1) = sind(gamma);
cada1f1 = cosd(gamma.f);
R.f(2,2) = cada1f1;
%User Line: R(2, 2) = cosd(gamma);
R.f(3,3) = 1;
%User Line: R(3, 3) = 1;
end


function ADiGator_LoadData()
global ADiGator_ft_1_t_ADiGatorJac
ADiGator_ft_1_t_ADiGatorJac = load('ft_1_t_ADiGatorJac.mat');
return
end