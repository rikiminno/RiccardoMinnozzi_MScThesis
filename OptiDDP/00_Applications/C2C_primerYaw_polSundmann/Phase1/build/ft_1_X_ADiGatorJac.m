% This code was generated using ADiGator version 1.4
% Â©2010-2014 Matthew J. Weinstein and Anil V. Rao
% ADiGator may be obtained at https://sourceforge.net/projects/adigator/ 
% Contact: mweinstein@ufl.edu
% Bugs/suggestions may be reported to the sourceforge forums
%                    DISCLAIMER
% ADiGator is a general-purpose software distributed under the GNU General
% Public License version 3.0. While the software is distributed with the
% hope that it will be useful, both the software and generated code are
% provided 'AS IS' with NO WARRANTIES OF ANY KIND and no merchantability
% or fitness for any purpose or application.

function Xdot = ft_1_X_ADiGatorJac(t,X)
global ADiGator_ft_1_X_ADiGatorJac
if isempty(ADiGator_ft_1_X_ADiGatorJac); ADiGator_LoadData(); end
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ft_1_X_ADiGatorJac.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % Augmented state derivative wrapper function for phase 1,
%User Line: % automatically generated by the PhaseManager class on 06-Dec-2024 12:49:23
%User Line: % Increase dynamics function evaluations
global HOIST_fevalsCount_ft 
%User Line: global
HOIST_fevalsCount_ft = HOIST_fevalsCount_ft + 1;
%User Line: HOIST_fevalsCount_ft = HOIST_fevalsCount_ft + 1;
x.dX = X.dX(Gator1Data.Index2);
x.f = X.f(Gator1Data.Index1,1);
%User Line: x = X(1: 4, 1);
u.dX = X.dX(5);
u.f = X.f(5,1);
%User Line: u = X(5: 5, 1);
w.dX = X.dX(6);
w.f = X.f(6,1);
%User Line: w = X(6: 6, 1);
cadainput2_1 = t;
%User Line: cadainput2_1 = t;
cadainput2_2.dX = x.dX; cadainput2_2.f = x.f;
%User Line: cadainput2_2 = x;
cadainput2_3.dX = u.dX; cadainput2_3.f = u.f;
%User Line: cadainput2_3 = u;
cadainput2_4.dX = w.dX; cadainput2_4.f = w.f;
%User Line: cadainput2_4 = w;
cadaoutput2_1 = ADiGator_state_derivative_1(cadainput2_1,cadainput2_2,cadainput2_3,cadainput2_4);
% Call to function: state_derivative_1
xdot.dX = cadaoutput2_1.dX; xdot.f = cadaoutput2_1.f;
%User Line: xdot = cadaoutput2_1;
udot.f =  zeros(1, 1);
%User Line: udot = zeros(1, 1);
wdot.f =  zeros(1, 1);
%User Line: wdot = zeros(1, 1);
cada1td1 = zeros(14,1);
cada1td1(Gator1Data.Index3) = xdot.dX;
Xdot.dX = cada1td1;
Xdot.f = [xdot.f;udot.f;wdot.f];
%User Line: Xdot = [xdot; udot; wdot];
Xdot.dX_size = [6,6];
Xdot.dX_location = Gator1Data.Index4;
end
function xdot = ADiGator_state_derivative_1(t,x,u,w)
global ADiGator_ft_1_X_ADiGatorJac
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ADiGator_state_derivative_1.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % function that computes the state derivative
global auxdata 
%User Line: global
%User Line: % assemble state
rbar.dX = x.dX(1);
rbar.f = x.f(1);
%User Line: rbar = x(1);
tbar.dX = x.dX(2);
tbar.f = x.f(2);
%User Line: tbar = x(2);
ubar.dX = x.dX(3);
ubar.f = x.f(3);
%User Line: ubar = x(3);
vbar.dX = x.dX(4);
vbar.f = x.f(4);
%User Line: vbar = x(4);
theta.f = t*auxdata.thetaf;
%User Line: theta = t * auxdata.thetaf;
%User Line: % define rotation matrices
trueRAAN.f = 180 - auxdata.Omg;
%User Line: trueRAAN = 180 - auxdata.Omg;
cadainput10_1.f = trueRAAN.f;
%User Line: cadainput10_1 = trueRAAN;
cadainput10_1.dX = zeros(1,1);
cadaoutput10_1 = ADiGator_rotate_z_deg(cadainput10_1);
% Call to function: rotate_z_deg
cadaoutput10_1 = rmfield(cadaoutput10_1,'dX');
R_Omg.f = cadaoutput10_1.f;
%User Line: R_Omg = cadaoutput10_1;
cadainput8_1 = auxdata.inc;
%User Line: cadainput8_1 = auxdata.inc;
cadaoutput8_1 = ADiGator_rotate_x_deg(cadainput8_1);
% Call to function: rotate_x_deg
R_inc.f = cadaoutput8_1.f;
%User Line: R_inc = cadaoutput8_1;
cadainput9_1.f = theta.f;
%User Line: cadainput9_1 = theta;
cadaoutput9_1 = ADiGator_rotate_z(cadainput9_1);
% Call to function: rotate_z
R_CRK_to_RSW.f = cadaoutput9_1.f;
%User Line: R_CRK_to_RSW = cadaoutput9_1;
R_CRK_to_IJK.f = R_Omg.f*R_inc.f;
%User Line: R_CRK_to_IJK = R_Omg * R_inc;
cada1f1 = R_CRK_to_RSW.f.';
R_RSW_to_IJK.f = R_CRK_to_IJK.f*cada1f1;
%User Line: R_RSW_to_IJK = R_CRK_to_IJK * R_CRK_to_RSW';
cada1f1dX = auxdata.T0.*tbar.dX;
cada1f1 = tbar.f*auxdata.T0;
tDays.dX = cada1f1dX./86400;
tDays.f = cada1f1/86400;
%User Line: tDays = tbar * auxdata.T0 / 86400;
cadainput10_1.dX = tDays.dX; cadainput10_1.f = tDays.f;
%User Line: cadainput10_1 = tDays;
cadaoutput10_1 = ADiGator_rotate_z_deg(cadainput10_1);
% Call to function: rotate_z_deg
R_SLF_to_IJK.dX = cadaoutput10_1.dX; R_SLF_to_IJK.f = cadaoutput10_1.f;
%User Line: R_SLF_to_IJK = cadaoutput10_1;
%User Line: % define unit vectors
i.f =  [1; 0; 0];
%User Line: i = [1; 0; 0];
j.f =  [0; 1; 0];
%User Line: j = [0; 1; 0];
k.f =  [0; 0; 1];
%User Line: k = [0; 0; 1];
cada1td1 = zeros(3,2);
cada1td1(Gator1Data.Index1) = R_SLF_to_IJK.dX;
cada1td1 = i.f.'*cada1td1;
cada1td1 = cada1td1(:);
r_SS.dX = cada1td1(Gator1Data.Index2);
r_SS.f = R_SLF_to_IJK.f*i.f;
%User Line: r_SS = R_SLF_to_IJK * i;
%User Line: % define primer yaw vector
yaw.dX = u.dX; yaw.f = u.f;
%User Line: yaw = u;
%User Line: % assemble primer vector in local frame
cada1f1dX = cos(yaw.f).*yaw.dX;
cada1f1 = sin(yaw.f);
cada1f2dX = -sin(yaw.f).*yaw.dX;
cada1f2 = cos(yaw.f);
cada1td1 = zeros(2,1);
cada1td1(1) = cada1f1dX;
cada1td1(2) = cada1f2dX;
p_RSW.dX = cada1td1;
p_RSW.f = [cada1f1;cada1f2;0];
%User Line: p_RSW = [sin(yaw); cos(yaw); 0];
%User Line: % rotate primer vector to inertial
cada1td1 = zeros(3,1);
cada1td1(Gator1Data.Index3) = p_RSW.dX;
cada1td1 = R_RSW_to_IJK.f*cada1td1;
cada1td1 = cada1td1(:);
p_IJK.dX = cada1td1(Gator1Data.Index4);
p_IJK.f = R_RSW_to_IJK.f*p_RSW.f;
%User Line: p_IJK = R_RSW_to_IJK * p_RSW;
%User Line: % compute angle between primer vector and sun line
cadainput3_1.dX = p_IJK.dX; cadainput3_1.f = p_IJK.f;
%User Line: cadainput3_1 = p_IJK;
cadainput3_2.dX = r_SS.dX; cadainput3_2.f = r_SS.f;
%User Line: cadainput3_2 = r_SS;
cadaoutput3_1 = ADiGator_angleBetweenVectors(cadainput3_1,cadainput3_2);
% Call to function: angleBetweenVectors
psi.dX = cadaoutput3_1.dX; psi.f = cadaoutput3_1.f;
%User Line: psi = cadaoutput3_1;
%User Line: % compute optimal alpha angle from psi
cada1f1dX = cos(psi.f).*psi.dX;
cada1f1 = sin(psi.f);
cada1f2dX = cada1f1dX./3;
cada1f2 = cada1f1/3;
cada1f3dX = 1./sqrt(1-cada1f2.^2).*cada1f2dX;
cada1f3 = asin(cada1f2);
cada1td1 = psi.dX;
cada1td1 = cada1td1 + -cada1f3dX;
cada1f4dX = cada1td1;
cada1f4 = psi.f - cada1f3;
alpha.dX = 0.5.*cada1f4dX;
alpha.f = 0.5*cada1f4;
%User Line: alpha = 1/2*(psi - asin(sin(psi)/3));
%User Line: % compute the clock angle as the angle between the primer vector and the
%User Line: % chosen reference direction z (valid since it is perpendicular to the
%User Line: % Sun-line)
cada1f1dX = p_IJK.dX(2);
cada1f1 = p_IJK.f(2);
cada1f2dX = p_IJK.dX(3);
cada1f2 = p_IJK.f(3);
cada1td1 = cada1f2./(cada1f2.^2+cada1f1.^2).*cada1f1dX;
cada1td1 = cada1td1 + -cada1f1./(cada1f2.^2+cada1f1.^2).*cada1f2dX;
delta.dX = cada1td1;
delta.f = atan2(cada1f1,cada1f2);
%User Line: delta = atan2(p_IJK(2), p_IJK(3));
%User Line: % compute the solar sail acceleration in SunLight-frame
cada1f1dX = -sin(alpha.f).*alpha.dX;
cada1f1 = cos(alpha.f);
cada1f2dX = 2.*cada1f1.^(2-1).*cada1f1dX;
cada1f2 = cada1f1^2;
aMod.dX = auxdata.a0bar.*cada1f2dX;
aMod.f = auxdata.a0bar*cada1f2;
%User Line: aMod = auxdata.a0bar * cos(alpha)^2;
cada1f1dX = -sin(alpha.f).*alpha.dX;
cada1f1 = cos(alpha.f);
cada1td1 = cada1f1.*aMod.dX;
cada1td1 = cada1td1 + aMod.f.*cada1f1dX;
cada1f2dX = cada1td1;
cada1f2 = aMod.f*cada1f1;
cada1tempdX = cada1f2dX(Gator1Data.Index5);
cada1tf1 = i.f(Gator1Data.Index7);
cada1f3dX = cada1tf1(:).*cada1tempdX(Gator1Data.Index6);
cada1f3 = cada1f2*i.f;
cada1f4dX = cos(alpha.f).*alpha.dX;
cada1f4 = sin(alpha.f);
cada1td1 = cada1f4.*aMod.dX;
cada1td1 = cada1td1 + aMod.f.*cada1f4dX;
cada1f5dX = cada1td1;
cada1f5 = aMod.f*cada1f4;
cada1f6dX = cos(delta.f).*delta.dX;
cada1f6 = sin(delta.f);
cada1td1 = cada1f6.*cada1f5dX;
cada1td1(2) = cada1td1(2) + cada1f5.*cada1f6dX;
cada1f7dX = cada1td1;
cada1f7 = cada1f5*cada1f6;
cada1tempdX = cada1f7dX(Gator1Data.Index8);
cada1tf1 = j.f(Gator1Data.Index10);
cada1f8dX = cada1tf1(:).*cada1tempdX(Gator1Data.Index9);
cada1f8 = cada1f7*j.f;
cada1td1 = zeros(4,1);
cada1td1(Gator1Data.Index11) = cada1f3dX;
cada1td1(Gator1Data.Index12) = cada1td1(Gator1Data.Index12) + cada1f8dX;
cada1f9dX = cada1td1;
cada1f9 = cada1f3 + cada1f8;
cada1f10dX = cos(alpha.f).*alpha.dX;
cada1f10 = sin(alpha.f);
cada1td1 = cada1f10.*aMod.dX;
cada1td1 = cada1td1 + aMod.f.*cada1f10dX;
cada1f11dX = cada1td1;
cada1f11 = aMod.f*cada1f10;
cada1f12dX = -sin(delta.f).*delta.dX;
cada1f12 = cos(delta.f);
cada1td1 = cada1f12.*cada1f11dX;
cada1td1(2) = cada1td1(2) + cada1f11.*cada1f12dX;
cada1f13dX = cada1td1;
cada1f13 = cada1f11*cada1f12;
cada1tempdX = cada1f13dX(Gator1Data.Index13);
cada1tf1 = k.f(Gator1Data.Index15);
cada1f14dX = cada1tf1(:).*cada1tempdX(Gator1Data.Index14);
cada1f14 = cada1f13*k.f;
cada1td1 = zeros(6,1);
cada1td1(Gator1Data.Index16) = cada1f9dX;
cada1td1(Gator1Data.Index17) = cada1td1(Gator1Data.Index17) + cada1f14dX;
a_SLF.dX = cada1td1;
a_SLF.f = cada1f9 + cada1f14;
%User Line: a_SLF = aMod * cos(alpha) .* i     + aMod * sin(alpha) * sin(delta) * j     + aMod * sin(alpha) * cos(delta) * k;
%User Line: % rotate the sail acceleration to local frame
cada1td2 = zeros(3,2);
cada1td2(Gator1Data.Index18) = R_SLF_to_IJK.dX;
cada1td2 = a_SLF.f.'*cada1td2;
cada1td1 = zeros(6,1);
cada1td1(Gator1Data.Index20) = cada1td2(Gator1Data.Index19);
cada1td2 = zeros(3,2);
cada1td2(Gator1Data.Index21) = a_SLF.dX;
cada1td2 = R_SLF_to_IJK.f*cada1td2;
cada1td2 = cada1td2(:);
cada1td1 = cada1td1 + cada1td2(Gator1Data.Index22);
a_IJK.dX = cada1td1;
a_IJK.f = R_SLF_to_IJK.f*a_SLF.f;
%User Line: a_IJK = R_SLF_to_IJK * a_SLF;
cada1f1 = R_RSW_to_IJK.f.';
cada1td1 = zeros(3,2);
cada1td1(Gator1Data.Index23) = a_IJK.dX;
cada1td1 = cada1f1*cada1td1;
cada1td1 = cada1td1(:);
a_RSW.dX = cada1td1(Gator1Data.Index24);
a_RSW.f = cada1f1*a_IJK.f;
%User Line: a_RSW = R_RSW_to_IJK' * a_IJK;
%User Line: % assemble EOMs
eta = auxdata.eta;
%User Line: eta = auxdata.eta;
cada1td1 = zeros(2,1);
cada1td1(2) = vbar.dX./rbar.f;
cada1td1(1) = cada1td1(1) + -vbar.f./rbar.f.^2.*rbar.dX;
cada1f1dX = cada1td1;
cada1f1 = vbar.f/rbar.f;
cada1f2dX = eta.*cada1f1dX;
cada1f2 = cada1f1*eta;
sigma.dX = cada1f2dX./auxdata.thetaf;
sigma.f = cada1f2/auxdata.thetaf;
%User Line: sigma = (vbar / rbar) * eta / auxdata.thetaf;
cada1f1dX = eta.*ubar.dX;
cada1f1 = ubar.f*eta;
cada1td1 = zeros(3,1);
cada1td1(2) = cada1f1dX./sigma.f;
cada1td1(Gator1Data.Index25) = cada1td1(Gator1Data.Index25) + -cada1f1./sigma.f.^2.*sigma.dX;
drbar.dX = cada1td1;
drbar.f = cada1f1/sigma.f;
%User Line: drbar = ubar * eta / sigma;
dtime.dX = -1./sigma.f.^2.*sigma.dX;
dtime.f = 1/sigma.f;
%User Line: dtime = 1 / sigma;
cada1f1dX = 2.*vbar.f.^(2-1).*vbar.dX;
cada1f1 = vbar.f^2;
cada1td1 = zeros(2,1);
cada1td1(2) = cada1f1dX./rbar.f;
cada1td1(1) = cada1td1(1) + -cada1f1./rbar.f.^2.*rbar.dX;
cada1f2dX = cada1td1;
cada1f2 = cada1f1/rbar.f;
cada1f3dX = 2.*rbar.f.^(2-1).*rbar.dX;
cada1f3 = rbar.f^2;
cada1f4dX = -1./cada1f3.^2.*cada1f3dX;
cada1f4 = 1/cada1f3;
cada1td1 = cada1f2dX;
cada1td1(1) = cada1td1(1) + -cada1f4dX;
cada1f5dX = cada1td1;
cada1f5 = cada1f2 - cada1f4;
cada1f6dX = eta.*cada1f5dX;
cada1f6 = cada1f5*eta;
cada1f7dX = a_RSW.dX(Gator1Data.Index26);
cada1f7 = a_RSW.f(1);
cada1td1 = zeros(4,1);
cada1td1(Gator1Data.Index27) = cada1f6dX;
cada1td1(Gator1Data.Index28) = cada1td1(Gator1Data.Index28) + cada1f7dX;
cada1f8dX = cada1td1;
cada1f8 = cada1f6 + cada1f7;
cada1td1 = cada1f8dX./sigma.f;
cada1td1(Gator1Data.Index29) = cada1td1(Gator1Data.Index29) + -cada1f8./sigma.f.^2.*sigma.dX;
dubar.dX = cada1td1;
dubar.f = cada1f8/sigma.f;
%User Line: dubar = ((vbar^2/rbar - 1/rbar^2) * eta + a_RSW(1)) / sigma;
cada1f1dX = -ubar.dX;
cada1f1 = uminus(ubar.f);
cada1td1 = zeros(2,1);
cada1td1(1) = vbar.f.*cada1f1dX;
cada1td1(2) = cada1td1(2) + cada1f1.*vbar.dX;
cada1f2dX = cada1td1;
cada1f2 = cada1f1*vbar.f;
cada1td1 = zeros(3,1);
cada1td1(Gator1Data.Index30) = cada1f2dX./rbar.f;
cada1td1(1) = cada1td1(1) + -cada1f2./rbar.f.^2.*rbar.dX;
cada1f3dX = cada1td1;
cada1f3 = cada1f2/rbar.f;
cada1f4dX = eta.*cada1f3dX;
cada1f4 = cada1f3*eta;
cada1f5dX = a_RSW.dX(Gator1Data.Index31);
cada1f5 = a_RSW.f(2);
cada1td1 = zeros(5,1);
cada1td1(Gator1Data.Index32) = cada1f4dX;
cada1td1(Gator1Data.Index33) = cada1td1(Gator1Data.Index33) + cada1f5dX;
cada1f6dX = cada1td1;
cada1f6 = cada1f4 + cada1f5;
cada1td1 = cada1f6dX./sigma.f;
cada1td1(Gator1Data.Index34) = cada1td1(Gator1Data.Index34) + -cada1f6./sigma.f.^2.*sigma.dX;
dvbar.dX = cada1td1;
dvbar.f = cada1f6/sigma.f;
%User Line: dvbar = (- ubar * vbar / rbar * eta + a_RSW(2)) / sigma;
cada1td1 = zeros(14,1);
cada1td1(Gator1Data.Index35) = drbar.dX;
cada1td1(Gator1Data.Index36) = dtime.dX;
cada1td1(Gator1Data.Index37) = dubar.dX;
cada1td1(Gator1Data.Index38) = dvbar.dX;
xdot.dX = cada1td1;
xdot.f = [drbar.f;dtime.f;dubar.f;dvbar.f];
%User Line: xdot = [drbar; dtime; dubar; dvbar];
end
function angle = ADiGator_angleBetweenVectors(vec1,vec2)
global ADiGator_ft_1_X_ADiGatorJac
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ADiGator_angleBetweenVectors.Gator1Data;
% ADiGator Start Derivative Computations
cadainput5_1.dX = vec1.dX; cadainput5_1.f = vec1.f;
%User Line: cadainput5_1 = vec1;
cadainput5_2.dX = vec2.dX; cadainput5_2.f = vec2.f;
%User Line: cadainput5_2 = vec2;
cadaoutput5_1 = ADiGator_myCross(cadainput5_1,cadainput5_2);
% Call to function: myCross
c.dX = cadaoutput5_1.dX; c.f = cadaoutput5_1.f;
%User Line: c = cadaoutput5_1;
cadainput4_1.dX = c.dX; cadainput4_1.f = c.f;
%User Line: cadainput4_1 = c;
cadaoutput4_1 = ADiGator_myNorm(cadainput4_1);
% Call to function: myNorm
n.dX = cadaoutput4_1.dX; n.f = cadaoutput4_1.f;
%User Line: n = cadaoutput4_1;
cada1f1dX = vec1.dX;
cada1f1 = vec1.f.';
cada1td2 = zeros(3,1);
cada1td2(Gator1Data.Index1) = cada1f1dX;
cada1td2 = vec2.f.'*cada1td2;
cada1td1 = zeros(2,1);
cada1td1(2) = cada1td2(1);
cada1td2 = zeros(3,1);
cada1td2(Gator1Data.Index2) = vec2.dX;
cada1td2 = cada1f1*cada1td2;
cada1td2 = cada1td2(:);
cada1td1(1) = cada1td1(1) + cada1td2(1);
d.dX = cada1td1;
d.f = cada1f1*vec2.f;
%User Line: d = vec1' * vec2;
cada1td1 = d.f./(d.f.^2+n.f.^2).*n.dX;
cada1td1 = cada1td1 + -n.f./(d.f.^2+n.f.^2).*d.dX;
angle_tmp.dX = cada1td1;
angle_tmp.f = atan2(n.f,d.f);
%User Line: angle_tmp = atan2(n, d);
cadainput6_1.dX = angle_tmp.dX; cadainput6_1.f = angle_tmp.f;
%User Line: cadainput6_1 = angle_tmp;
cadaoutput6_1 = ADiGator_mySign(cadainput6_1);
% Call to function: mySign
angSign.f = cadaoutput6_1.f;
%User Line: angSign = cadaoutput6_1;
angle.dX = angSign.f.*angle_tmp.dX;
angle.f = angSign.f*angle_tmp.f;
%User Line: angle = angSign * angle_tmp;
end
function n = ADiGator_myNorm(vec)
global ADiGator_ft_1_X_ADiGatorJac
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ADiGator_myNorm.Gator1Data;
% ADiGator Start Derivative Computations
cada1f1dX = vec.dX(Gator1Data.Index1);
cada1f1 = vec.f(1);
cada1f2dX = 2.*cada1f1.^(2-1).*cada1f1dX;
cada1f2 = cada1f1^2;
cada1f3dX = vec.dX(Gator1Data.Index2);
cada1f3 = vec.f(2);
cada1f4dX = 2.*cada1f3.^(2-1).*cada1f3dX;
cada1f4 = cada1f3^2;
cada1td1 = cada1f2dX;
cada1td1 = cada1td1 + cada1f4dX;
cada1f5dX = cada1td1;
cada1f5 = cada1f2 + cada1f4;
cada1f6dX = vec.dX(Gator1Data.Index3);
cada1f6 = vec.f(3);
cada1f7dX = 2.*cada1f6.^(2-1).*cada1f6dX;
cada1f7 = cada1f6^2;
cada1td1 = cada1f5dX;
cada1td1 = cada1td1 + cada1f7dX;
cada1f8dX = cada1td1;
cada1f8 = cada1f5 + cada1f7;
n.dX = (1/2)./sqrt(cada1f8).*cada1f8dX;
n.dX(cada1f8 == 0 & cada1f8dX == 0) = 0;
n.f = sqrt(cada1f8);
%User Line: n = sqrt(vec(1)^2 + vec(2)^2 + vec(3)^2);
end
function result = ADiGator_myCross(vec1,vec2)
global ADiGator_ft_1_X_ADiGatorJac
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ADiGator_myCross.Gator1Data;
% ADiGator Start Derivative Computations
result.f =  zeros(3, 1);
%User Line: result = zeros(3, 1);
cada1f1dX = vec1.dX(2);
cada1f1 = vec1.f(2);
cada1f2 = vec2.f(3);
cada1f3 = cada1f1*cada1f2;
cada1f4dX = vec1.dX(3);
cada1f4 = vec1.f(3);
cada1f5dX = vec2.dX(2);
cada1f5 = vec2.f(2);
cada1td1 = zeros(2,1);
cada1td1(2) = cada1f5.*cada1f4dX;
cada1td1(1) = cada1td1(1) + cada1f4.*cada1f5dX;
cada1f6dX = cada1td1;
cada1f6 = cada1f4*cada1f5;
cada1f7dX = -cada1f6dX;
cada1f7 = cada1f3 - cada1f6;
result.dX = cada1f7dX;
result.f(1,1) = cada1f7;
%User Line: result(1, 1) = vec1(2) * vec2(3) - vec1(3) * vec2(2);
cada1f1dX = vec1.dX(3);
cada1f1 = vec1.f(3);
cada1f2dX = vec2.dX(1);
cada1f2 = vec2.f(1);
cada1td1 = zeros(2,1);
cada1td1(2) = cada1f2.*cada1f1dX;
cada1td1(1) = cada1td1(1) + cada1f1.*cada1f2dX;
cada1f3dX = cada1td1;
cada1f3 = cada1f1*cada1f2;
cada1f4dX = vec1.dX(1);
cada1f4 = vec1.f(1);
cada1f5 = vec2.f(3);
cada1f6 = cada1f4*cada1f5;
cada1f7dX = cada1f3dX;
cada1f7 = cada1f3 - cada1f6;
cada1td1 = zeros(4,1);
cada1td1(Gator1Data.Index1) = cada1f7dX;
cada1td1(Gator1Data.Index2) = result.dX(Gator1Data.Index3);
result.dX = cada1td1;
result.f(2,1) = cada1f7;
%User Line: result(2, 1) = vec1(3) * vec2(1) - vec1(1) * vec2(3);
cada1f1dX = vec1.dX(1);
cada1f1 = vec1.f(1);
cada1f2dX = vec2.dX(2);
cada1f2 = vec2.f(2);
cada1td1 = zeros(2,1);
cada1td1(2) = cada1f2.*cada1f1dX;
cada1td1(1) = cada1td1(1) + cada1f1.*cada1f2dX;
cada1f3dX = cada1td1;
cada1f3 = cada1f1*cada1f2;
cada1f4dX = vec1.dX(2);
cada1f4 = vec1.f(2);
cada1f5dX = vec2.dX(1);
cada1f5 = vec2.f(1);
cada1td1 = zeros(2,1);
cada1td1(2) = cada1f5.*cada1f4dX;
cada1td1(1) = cada1td1(1) + cada1f4.*cada1f5dX;
cada1f6dX = cada1td1;
cada1f6 = cada1f4*cada1f5;
cada1td1 = cada1f3dX;
cada1td1 = cada1td1 + -cada1f6dX;
cada1f7dX = cada1td1;
cada1f7 = cada1f3 - cada1f6;
cada1td1 = zeros(6,1);
cada1td1(Gator1Data.Index4) = cada1f7dX;
cada1td1(Gator1Data.Index5) = result.dX(Gator1Data.Index6);
result.dX = cada1td1;
result.f(3,1) = cada1f7;
%User Line: result(3, 1) = vec1(1) * vec2(2) - vec1(2) * vec2(1);
end
function s = ADiGator_mySign(num)
global ADiGator_ft_1_X_ADiGatorJac
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ADiGator_mySign.Gator1Data;
% ADiGator Start Derivative Computations
cadaconditional1 = ge(num.f,0);
%User Line: cadaconditional1 = num >= 0;
if cadaconditional1
    s.f =  1;
    %User Line: s = 1;
else
    s.f =  -1;
    %User Line: s = -1;
end
end
function R = ADiGator_rotate_x_deg(alpha)
global ADiGator_ft_1_X_ADiGatorJac
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ADiGator_rotate_x_deg.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % function to output the rotation matrix for a rotation around the x axis
%User Line: % by angle alpha [deg]
R.f =  zeros(3, 3);
%User Line: R = zeros(3, 3);
R.f(1,1) = 1;
%User Line: R(1, 1) = 1;
cada1f1 = cosd(alpha);
R.f(2,2) = cada1f1;
%User Line: R(2, 2) = cosd(alpha);
cada1f1 = sind(alpha);
cada1f2 = uminus(cada1f1);
R.f(2,3) = cada1f2;
%User Line: R(2, 3) = -sind(alpha);
cada1f1 = sind(alpha);
R.f(3,2) = cada1f1;
%User Line: R(3, 2) = sind(alpha);
cada1f1 = cosd(alpha);
R.f(3,3) = cada1f1;
%User Line: R(3, 3) = cosd(alpha);
end
function R = ADiGator_rotate_z(gamma)
global ADiGator_ft_1_X_ADiGatorJac
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ADiGator_rotate_z.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % function to output the rotation matrix for a rotation around the z axis
%User Line: % by angle gamma [rad]
R.f =  zeros(3, 3);
%User Line: R = zeros(3, 3);
cada1f1 = cos(gamma.f);
R.f(1,1) = cada1f1;
%User Line: R(1, 1) = cos(gamma);
cada1f1 = sin(gamma.f);
cada1f2 = uminus(cada1f1);
R.f(1,2) = cada1f2;
%User Line: R(1, 2) = -sin(gamma);
cada1f1 = sin(gamma.f);
R.f(2,1) = cada1f1;
%User Line: R(2, 1) = sin(gamma);
cada1f1 = cos(gamma.f);
R.f(2,2) = cada1f1;
%User Line: R(2, 2) = cos(gamma);
R.f(3,3) = 1;
%User Line: R(3, 3) = 1;
end
function R = ADiGator_rotate_z_deg(gamma)
global ADiGator_ft_1_X_ADiGatorJac
Gator1Data = ADiGator_ft_1_X_ADiGatorJac.ADiGator_rotate_z_deg.Gator1Data;
% ADiGator Start Derivative Computations
%User Line: % function to output the rotation matrix for a rotation around the z axis
%User Line: % by angle gamma [deg]
R.f =  zeros(3, 3);
R.dX = zeros(4,1);
%User Line: R = zeros(3, 3);
cada1f1dX = -pi/180.*sind(gamma.f).*gamma.dX;
cada1f1 = cosd(gamma.f);
R.dX(logical(Gator1Data.Index1)) = cada1f1dX(nonzeros(Gator1Data.Index1));
R.f(1,1) = cada1f1;
%User Line: R(1, 1) = cosd(gamma);
cada1f1dX = pi/180.*cosd(gamma.f).*gamma.dX;
cada1f1 = sind(gamma.f);
cada1f2dX = -cada1f1dX;
cada1f2 = uminus(cada1f1);
R.dX(logical(Gator1Data.Index2)) = cada1f2dX(nonzeros(Gator1Data.Index2));
R.f(1,2) = cada1f2;
%User Line: R(1, 2) = -sind(gamma);
cada1f1dX = pi/180.*cosd(gamma.f).*gamma.dX;
cada1f1 = sind(gamma.f);
R.dX(logical(Gator1Data.Index3)) = cada1f1dX(nonzeros(Gator1Data.Index3));
R.f(2,1) = cada1f1;
%User Line: R(2, 1) = sind(gamma);
cada1f1dX = -pi/180.*sind(gamma.f).*gamma.dX;
cada1f1 = cosd(gamma.f);
R.dX(logical(Gator1Data.Index4)) = cada1f1dX(nonzeros(Gator1Data.Index4));
R.f(2,2) = cada1f1;
%User Line: R(2, 2) = cosd(gamma);
R.f(3,3) = 1;
%User Line: R(3, 3) = 1;
end


function ADiGator_LoadData()
global ADiGator_ft_1_X_ADiGatorJac
ADiGator_ft_1_X_ADiGatorJac = load('ft_1_X_ADiGatorJac.mat');
return
end